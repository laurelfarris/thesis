

;- 14 December 2018

;- This code plots polygons on top of existing image.

goto, start


;- To do:
;-   Write image_powermaps.pro to be more generalized.
;-   Better way to distinguish between aia and hmi start indices,
;-      currently aia starts at z_start and hmi starts at zz...
;-      not what I'd call intuitive.


;- Steps:
;-   1. Image AIA intensity/powermaps
;-     IDL> .run image_powermaps   ; uses image3.pro (subsubroutine)
;-   2. Overlay HMI B_LOS contours on image(s) generated by image_powermaps.pro
;-     IDL> .run contours
;-   3. Overlay polygons on top of subregions.

;- NOTE: can reverse order of steps 2. and 3., or only call one of them.
;-  Just be sure to create image first.
;- Though for current purposes (plotting power vs. magnetic field)
;-  do need both. And better to run contours first so they won't lay
;-  on top of polygons. Could use send_to_back method, but I
;-  don't feel like it.


;z_start = [ $
;    16, 58, 196, $
;    216, 248, 280, $
;    314, 386, 450, $
;    525, 600, 658 ]

;- Space
;- Center coords of each subregion (and hence, polygon)
;-  --> need center variable for both polygons AND plots.
center = [ $
    [ 80, 120], $
    [115, 090], $
    [115, 115], $
    [160, 155], $
    [230, 145], $
    [230, 190], $
    [255, 155], $
    [280, 180], $
    [367, 213], $
    [382, 193] ]


start:;---------------------------------------------------------------------------------


;- Thu Jan 24 11:36:54 MST 2019
;-   Comparing P(t) plots for subregions.


;- 1-3 plus 2 new subregions, one also in AR_2b, one in quiescent region.
center = [ $
    ;[ 80, 120], $ --> saturated
    [128, 143], $
    [115, 090], $
    [115, 115], $
    [142, 110], $
    [110,  45] ]


;- length of one side of square polygon.
r = 20
;-----------
;- 27 January 2019

center = [ $
    [373,217], $
    [390,215] ]
r = 5

;---------



mm = (size(center,/dimensions))[1]

;pol = POLYGON_SUBREGIONS( center, target=im, width=r, color=color )
;- I'm guessing there was some intermediate routine that would
;- Loop through number of coords and call POLYGON or POLYGON2 inside
;- each loop. Can't find that file though, so guess I'll loop right here.

@color


;foreach pp, pol do pp.delete

pol = objarr(mm)
for ii = 0, mm-1 do begin
    pol[ii] = POLYGON2( $
        target=im[0], $
        center=center[*,ii], $
        dimensions=[r,r], $
        thick=2.0, $
        color=color[ii] )
endfor
stop

;- Where target "im" is created in ML after .RUN image_powermaps...
;- This is way too sloppy. I like the idea of separating each graphic
;-  (image, apply contours, apply polygons, --> 3 different things).
;- But this is too confusing. Should probably have ONE routine that
;-  calls ALL subroutines from one place.
;- Maybe I was just getting a general routine STARTED for imaging
;-  powermaps and just wasn't able to get very far...
;-   COOOMMMEENNNTSSSSSSSSSSS

;foreach pp, pol do pp.hide=1
;foreach pp, pol do pp.hide=0

;file = 'aia' + A[cc].channel + 'maps_contours_subregions'
;save2, file


;- Plot 3-minute power of subregions as function of magnetic field strength.
;-   (no spatial info here).


;- IDL> .run powermap_mask
;-  --> may speed this up by giving the option of using same subset
;-  of data that each subregion covers, rather than calculating mask
;- over entire AR even though barely using a tiny fraction of that data.


;---------------------------------------------------------------------------------

cc = 0
threshold = 15000.


aia_dz = 64
hmi_dz = (25.6 * 60)/H[0].cadence

;- Time
;- AIA z-indices, need to be converted for HMI
z_start = [ $
      [0, 16, 27, 58, 80, 90, 147, 175, 196 ], $
    [197, 200, 203, 216, 248, 265, 280, 291, 311], $
    [387, 405, 450, 467, 475, 525, 625, 660, 685] ]

nn = (size(z_start, /dimensions))[0]
n_phases = (size(z_start, /dimensions))[1]


;print, z_start*(A[cc].cadence/H[0].cadence)

; 'ind', rather than 'start', because only using this one loc.
hmi_zind = (z_start*(A[cc].cadence/H[0].cadence)) + (hmi_dz/2)


xdata = make_array( mm, nn, n_phases, /nozero )
ydata = make_array( mm, nn, n_phases, /nozero )


        ;- Quick check that using correct date_obs for HMI
        ;- Should be around 01:19-01:44 UT.
        ;print, H[0].time[z_ind[0]]
        ;print, H[0].time[z_ind[-1]]


;- Loop once for each phase: BDA
for tt = 0, n_phases-1 do begin

    ;- Loop through each time segment within current phase, tt
    foreach zz, z_start[*,tt], jj do begin

        ;- Iterate over each subregion
        for ii = 0, mm-1 do begin

            x0 = center[0,ii]
            y0 = center[1,ii]

            aia_zind = [zz:zz+aia_dz-1]

            ;- Calculate average magnetic field strength over subregion.
            ;- Note that hmi is still a 3D array after cropping, if trying
            ;- to properly average or sum over entire time segment that
            ;- is covered by 3minute power.
            ;- If using middle of time segment, then hmi will be 2D array.
            ;hmi_zind = [ (zz*(24./45.)) : (zz*(24./45.)) + (hmi_dz/2) ]

            ;- HMI index for CENTER of time segment
            ;hmi_zind = (zz*(24./45.)) + (hmi_dz/2)

            ;- Crop HMI data to subregion.
            hmi = CROP_DATA( $
                H[0].data, dimensions=[r,r], center=[x0,y0], $
                z_ind = hmi_zind[jj,tt] )

            ;- Calculate mean over magnetic field strength.
            xdata[ii,jj,tt] = mean(abs(hmi))



            ;- Compute data_mask to get number of unsaturated pixels.
            ;- (Even though already computed this over entire AR and
            ;- divided each AIA channel map by mask... not very efficient).
            data_mask = CROP_DATA( $
                A[cc].data, dimensions=[r,r], center=[x0,y0], $
                z_ind = aia_zind ) LT threshold

            ;- AIA power map subregions
            map = CROP_DATA( $
                A[cc].map, dimensions=[r,r], center=[x0,y0], $
                z_ind=aia_zind )

            ;- Reinventing the MEAN wheel, but only because need to divide
            ;- by number of unsaturated pixels.
            ydata[ii,jj,tt] = total(map)/total(data_mask)
        endfor
    endforeach
endfor

;---------------------------------------------------------------------------------

plt = plot3( xdata, ydata, rows=1, cols=3, buffer=0 )

stop

left = 0.75
bottom = 0.75
top = 0.75
right = 0.75

symbol = ['s', 'tu', 'o', 'D', '.', '+', '*', 's']
sym_size = [0.5, 1.5, 1.0]

@win

for ii = 0, nn-1 do begin

    sorted = sort(xdata)
    plt = PLOT2( $
        xdata[sorted], ydata[sorted], $
        /current, $
        /device, $
        ;overplot=ii<1, $
        layout=[1,1,1], $
        margin=[left, right, bottom, top]*dpi, $
        linestyle=0, $
        xstyle = ii, $
        ;aspect_ratio=0.2, $
        color=color[ii], $
        symbol=symbol[ii], $
        ;sym_filled = 0, $
        sym_size=sym_size[ii], $
        ;xtickinterval = 300, $
        ;xminor = 5, $
        title = 'Pre-flare', $
        xtitle = 'magnetic field strength', $
        ytitle = '3-minute power', $
        ;name = H[0].time[zz] + '-' + H[0].time[zz:zz+hmi_dz-1] $
        name = time[z_start] + '-' + H[0].time[zz:zz+hmi_dz-1] $
    )
endfor

;plt.aspect_ratio = $
;    ( (plt.xrange)[1] - (plt.xrange)[0] ) / $
;    ( (plt.yrange)[1] - (plt.yrange)[0] )

leg = legend2( target=plt, /upperright )
;ax = plt.axes
stop





;- Image power map and magnetic field used to generate plot(s).
;imdata = [ $
;    [[ alog10(A[0].map[*,*,0]) ]], $
;    [[ MEAN( H[0].data[*,*,0:hmi_dz-1], dimension=1 ) ]] ]


;- Could probably use same image/map/contour combos I already have...
;for ii = 0, 1 do begin
;    im = image2( $
;        imdata[*,*,ii], $
;        /current, $
;        layout=[1,2,ii+1], $
;        margin=0.1, $
;        rgb_table=A[0].ct, $
;        title=title[ii] )
;endfor


end
